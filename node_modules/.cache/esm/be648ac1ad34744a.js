let User,Joi,bcrypt,regesterValidate,issueTokens;_ad3‍.x([["default",()=>_ad3‍.o]]);_ad3‍.w("../../models",[["User",["User"],function(v){User=v}]]);_ad3‍.w("@hapi/joi",[["default",["Joi"],function(v){Joi=v}]]);_ad3‍.w("bcryptjs",[["default",["bcrypt"],function(v){bcrypt=v}]]);_ad3‍.w("../validators",[["regesterValidate",["regesterValidate"],function(v){regesterValidate=v}]]);_ad3‍.w("../../functions/auth",[["issueTokens",["issueTokens"],function(v){issueTokens=v}]]);




_ad3‍.d({
  Query: {
    users: () => {},
    login: () => {},
    profile: () => {},
    refreshToken: () => {},
  },
  Mutation: {
    register: async (root, args, { req }, info) => {
      _ad3‍.g.console.log(args);
      //Validate user data
      await Joi.valid(args, regesterValidate, { abortEarly: false });
      //Cheack if the user is already in the database with the same username
      let user = await User.findOne({ username: args.username });
      if (user) {
        throw new Error("Username already taken");
      }
      user = await User.findOne({ email: args.email });
      if (user) {
        throw new Error("Email already registered");
      }
      //If all passed now  hash the password and create the new user
      args.password = await bcrypt.hash(args.password, 10);
      _ad3‍.g.console.log(args.password)
      let newUser = await User.create(args);

      // issue the token and refreshToken
      let tokens = await issueTokens(newUser)
      _ad3‍.g.console.log(tokens)

      return {
        user: newUser,
        ...tokens
      };
    },
  },
});
